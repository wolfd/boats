(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["BoatContext`"];*)
(**)
(*(* DEBUG THING *)*)
(*ClearAll[debug];*)
(*SetAttributes[debug,HoldAll];*)
(*debug[code_]:=Internal`InheritedBlock[{Message},Module[{inMessage},Unprotect[Message];*)
(*Message[args___]/;!MatchQ[First[Hold[args]],_$Off]:=Block[{inMessage=True},Print[{Shallow/@Replace[#,HoldForm[f_[___]]:>HoldForm[f],1],Style[Map[Short,Last[#],{2}],Red]}&@Drop[Drop[Stack[_],-7],4]];*)
(*Message[args];*)
(*Throw[$Failed,Message];]/;!TrueQ[inMessage];*)
(*Protect[Message];];*)
(*Catch[StackComplete[code],Message]]*)
(**)
(*(* Standard Boat Library *)*)
(*Needs["CUDALink`"];*)
(**)
(*(* Generate point cloud from BoundaryMeshRegion *)*)
(*pointCloud[reg_?RegionQ,numPoints_]:=*)
(*RandomPoint[reg,numPoints];*)
(**)
(*ClearAll[sortPoints];*)
(*sortPoints[pts_,normal_]:=sortPoints[pts,normal]=*)
(*If[False,*)
(*CUDASort[CUDADot[pts,N[normal]]],*)
(*Sort[#.normal&/@pts]*)
(*];*)
(**)
(*ClearAll[waterLineOld];*)
(*(* Returns the index that puts a certain portion of the volume underwater *)*)
(*waterLineOld[pts_,normal_,meshVolume_,volumeUnderwater_]:=*)
(*waterLineOld[pts,normal,meshVolume,volumeUnderwater]=Module[{numPoints,dists},*)
(*numPoints=volumeUnderwater/meshVolume * Length[pts];*)
(*dists=sortPoints[pts,normal];*)
(*(* Possible improvement: linear interpolate between values at two points *)*)
(*dists[[Floor[numPoints]]]*)
(*];*)
(**)
(*ClearAll[waterLine];*)
(*waterLine[boat_,normal_,desiredVolumeUnderwater_]:=*)
(*Module[{bouys,bouy,bPoints,fullySubmergedVolume,indexOfWaterLine,pointDistances},*)
(*bouys=Select[boat,#[type]=="Bouy"&];*)
(*(* Only one bouy object per boat is allowed, due to different point masses *)*)
(*If[Length[bouys]!=1,Throw["No don't do that, one bouy per boat please"]];*)
(*bouy=bouys[[1]];*)
(**)
(*(* These operations are for many bouys, but only one bouy is valid *)*)
(*fullySubmergedVolume=volume/.bouy;*)
(*bPoints=points/.bouy;*)
(**)
(*(* Find how many points are underwater *)*)
(*indexOfWaterLine=desiredVolumeUnderwater/fullySubmergedVolume*Length[bPoints];*)
(**)
(*(* Index must be in range of points *)*)
(*If[indexOfWaterLine<1,Throw["Index not >= 1"]];*)
(*If[indexOfWaterLine>Length[bPoints],Throw["Index > number of points"]];*)
(**)
(*pointDistances=sortPoints[bPoints,normal];*)
(**)
(*(* Possible improvement: linear interpolate between values at two points *)*)
(*pointDistances[[Floor[indexOfWaterLine]]]*)
(*];*)
(**)
(*ClearAll[calculateVolumeUnderwater];*)
(*calculateVolumeUnderwater[boat_]:=*)
(*calculateVolumeUnderwater[boat]=*)
(*Module[{boatMass,displacedWaterVolume},*)
(*boatMass=Sum[p[mass],{p,Select[boat,#[type]=="PointMass"&]}];*)
(**)
(*displacedWaterVolume=boatMass/waterDensity*)
(*];*)
(**)
(*ClearAll[calculateWaterLine];*)
(*calculateWaterLine[boat_,wNormal_]:=*)
(*calculateWaterLine[boat,wNormal]=*)
(*waterLine[boat,wNormal,calculateVolumeUnderwater[boat]]*)
(**)
(*calculateForces[boat_,wNormal_]:=*)
(*Module[{bouys,bouy,masses,weightForces,bouyancyForce},*)
(*bouys=Select[boat,#[type]=="Bouy"&];*)
(*(* Assume prior exception thrown if not 1 element *)*)
(*bouy=bouys[[1]];*)
(**)
(*masses=Select[boat,#[type]=="PointMass"&];*)
(**)
(*(* Calculate the forces *)*)
(*bouyancyForce=calculateVolumeUnderwater[boat]*waterDensity*g*wNormal;*)
(*weightForces=#*(g*-wNormal)&/@(mass/.masses); (* Tricky replacement bullshit *)*)
(**)
(*<|*)
(*wfs-> weightForces,*)
(*bf->bouyancyForce*)
(*|>*)
(*];*)
(**)
(*(* Find the points of the bouyHull of a boat when translational forces are at equib *)*)
(*pointsBelowWaterLine[boat_,wNormal_]:=*)
(*Module[{bouy,waterHeight},*)
(*bouy=Select[boat,#[type]=="Bouy"&][[1]];*)
(*waterHeight=calculateWaterLine[boat,wNormal];*)
(**)
(*(* Dot products, get all points that are below the water height *)*)
(*pointsBelowWater=Select[points/.bouy,#.wNormal<=waterHeight&]*)
(*];*)
(**)
(*calculateCOM[boat_]:=*)
(*Module[{masses,coms,ms},*)
(*masses=Select[boat,#[type]=="PointMass"&];*)
(*coms=com/.masses;*)
(*ms=mass/.masses;*)
(*(Plus@@(coms*ms))/*)
(*Plus@@ms*)
(*];*)
(**)
(*(* Find the COB of a boat when translational forces are at equib *)*)
(*calculateCOB[boat_,wNormal_]:=*)
(*Module[{points},*)
(*points=pointsBelowWaterLine[boat,wNormal];*)
(*Quantity[Sum[p,{p,points}]/Length[points],"Centimeters"]*)
(*];*)
(**)
(*calculateMoments[boat_,wNormal_]:=*)
(*Module[{bouys,bouy,masses,forces,bouyancy,weights,bouyR,bouyMoment,weightsR,weightsMoments},*)
(*bouys=Select[boat,#[type]=="Bouy"&];*)
(*(* Assume prior exception thrown if not 1 element *)*)
(*bouy=bouys[[1]];*)
(**)
(*masses=Select[boat,#[type]=="PointMass"&];*)
(**)
(*(* Calculate the forces *)*)
(*forces=calculateForces[boat,wNormal];*)
(*weights=wfs/.forces;*)
(*bouyancy=bf/.forces;*)
(**)
(*(* Bouyancy moment *)*)
(*bouyR=calculateCOB[boat,wNormal];*)
(*bouyMoment=Cross[bouyR,bouyancy];*)
(**)
(*(* Calculate weights moments *)*)
(*weightsR=com/.masses;*)
(*weightsMoments=Cross@@@Transpose[{weightsR,weights}];*)
(**)
(*(* Return the moments *)*)
(*Prepend[weightsMoments,bouyMoment]*)
(*];*)
(**)
(*plotAVSMoments[boat_,samplePoints_]:=*)
(*Module[{moments,momentInterp,maxAngle=Pi/2},*)
(*(* Parallelize the creation of moments *)*)
(*moments=Parallelize[Table[*)
(*calculateMoments[boat,Normalize[{Cos[\[Theta]],0,Sin[\[Theta]]}]],*)
(*{\[Theta],0,maxAngle,maxAngle/samplePoints}*)
(*]];*)
(**)
(*momentInterp=ListInterpolation[*)
(*Table[*)
(*Norm[Plus@@moments[[n]]],*)
(*{n,Length[moments]}*)
(*],*)
(*{0,maxAngle}*)
(*];*)
(**)
(*Plot[*)
(*UnitConvert[momentInterp[\[Theta]],"NewtonMeters"],*)
(*{\[Theta],0,maxAngle},*)
(*AxesLabel->Automatic,*)
(*PlotLabel->"AVS"*)
(*]*)
(*];*)
(**)
(*(* Converts things into a dimension for rendering (based on STL dimension) *)*)
(*convertUnitsForRender[quant_]:=*)
(*Module[{},*)
(*UnitDimensions[quant]*)
(*];*)
(**)
(*renderBoat[boat_,wNormal_]:=*)
(*Module[{wl,waterPlane,pointMassParts,bouyParts,cob},*)
(*(* Calculate waterline to plot plane on *)*)
(*wl=calculateWaterLine[boat,wNormal];*)
(*waterPlane={Blue,Opacity[0.2],HalfSpace[wNormal,wNormal*wl]};*)
(**)
(*(* Grab all point masses to render *)*)
(*pointMassParts=Select[boat,#[type]=="PointMass"&];*)
(**)
(*(* Render bouy *)*)
(*bouyParts=Select[boat,#[type]=="Bouy"&][[1]];*)
(*cob=QuantityMagnitude[calculateCOB[boat,wNormal]];*)
(**)
(*Graphics3D[{waterPlane,render/.pointMassParts,(cobRender/.bouyParts)@cob}]*)
(*];*)
(**)
(*renderBoatWithForces[boat_,wNormal_]:=*)
(*Module[{front,forces,wForces,bForce,momentSum,com,scale,arrow,text,wVecs,bVec,mVecs,mText},*)
(*front=front/.Select[boat,#[type]=="Bouy"&][[1]];*)
(**)
(*forces=UnitConvert[calculateForces[boat,wNormal],"Newtons"];*)
(**)
(*wForces=wfs/.forces;*)
(*bForce=bf/.forces;*)
(**)
(*momentSum=UnitConvert[*)
(*Plus@@calculateMoments[boat,wNormal],*)
(*"NewtonMeters"];*)
(**)
(*com=QuantityMagnitude[calculateCOM[boat]];*)
(**)
(*scale=0.5;*)
(**)
(*arrow=Line[{com,com+(QuantityMagnitude[#]*scale)}]&;*)
(*text=Text[#,com+(QuantityMagnitude[#]*scale)]&;*)
(**)
(*wVecs={Red,arrow/@wForces};*)
(*bVec={Blue,arrow@bForce};*)
(*(* Arbitrary numbers to scale *)*)
(*mVecs={Purple,arrow@(momentSum*20)};*)
(**)
(*mText={text@momentSum};*)
(**)
(*Show[renderBoat[boat,wNormal],Graphics3D[{wVecs,bVec,mVecs}]]*)
(*];*)
(**)
(*EndPackage[];*)
